<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Flowchart with Simulation</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://unpkg.com/@material-ui/core@latest/umd/material-ui.production.min.css">
    <style>
        body {
            font-family: 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
            padding-bottom: 64px;
            overflow: hidden;
        }
        #title-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 64px;
            text-align: center;
            background-color: #fff;
            z-index: 1000;
            padding: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: none;
        }
        #title {
            font-size: 24px;
            margin: 0;
            cursor: pointer;
            line-height: 1.2;
        }
        #subheading {
            font-size: 16px;
            margin: 0;
            color: #666;
            cursor: pointer;
            line-height: 1.2;
        }
        #top-buttons {
            position: absolute;
            right: 16px;
            display: flex;
            gap: 8px;
        }
        #top-buttons button, #menu-button {
            padding: 6px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #f5f5f5;
            color: #212121;
            transition: background-color 0.2s;
        }
        #top-buttons button:hover, #menu-button:hover { background-color: #e0e0e0; }
        #top-buttons button:active, #menu-button:active { background-color: #bdbdbd; }
        #menu-button {
            position: absolute;
            left: 16px;
        }
        #flowchart-container {
            width: 100%;
            height: calc(100vh - 128px);
            position: absolute;
            top: 64px;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .node {
            stroke-width: 4;
            cursor: move;
        }
        .node-red { stroke: #FF5252; }
        .node-blue { stroke: #4285F4; }
        .node-green { stroke: #0F9D58; }
        .node-purple { stroke: #9C27B0; }
        .node-orange { stroke: #FF9800; }
        .node-fill {
            transition: y 0.3s, height 0.3s;
        }
        .node-text {
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: middle;
            font-family: 'Roboto', Arial, sans-serif;
            text-transform: lowercase;
            cursor: text;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .arrow {
            stroke: #000000;
            stroke-width: 2;
            fill: none;
            cursor: pointer;
        }
        .arrow-label {
            font-size: 14px;
            text-anchor: middle;
            font-family: 'Roboto', Arial, sans-serif;
            cursor: pointer;
        }
        .selected-glow {
            filter: drop-shadow(0 0 5px rgba(128, 128, 128, 0.8));
        }
        .menu-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            padding: 8px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.12);
            z-index: 1000;
            height: 64px;
            box-sizing: border-box;
            touch-action: none;
        }
        .menu-bar button {
            padding: 6px 16px;
            font-size: 14px;
            font-family: 'Roboto', Arial, sans-serif;
            text-transform: uppercase;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #f5f5f5;
            color: #212121;
            transition: background-color 0.2s;
        }
        .menu-bar button:hover { background-color: #e0e0e0; }
        .menu-bar button:active { background-color: #bdbdbd; }
        #add-circle-btn {
            background-color: #000000;
            color: #ffffff;
        }
        #add-circle-btn:hover { background-color: #333333; }
        #add-circle-btn:active { background-color: #666666; }
        #menu-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        #reset-zoom-btn {
            position: fixed;
            bottom: 80px;
            left: 16px;
            padding: 6px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #f5f5f5;
            color: #212121;
            transition: background-color 0.2s;
            z-index: 1001;
            display: none;
        }
        #reset-zoom-btn:hover { background-color: #e0e0e0; }
        #reset-zoom-btn:active { background-color: #bdbdbd; }
        #play-button {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #000;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }
        .play-icon {
            width: 0;
            height: 0;
            border-left: 15px solid white;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            margin-left: 5px;
        }
        .stop-icon {
            width: 20px;
            height: 20px;
            background-color: white;
        }
        .popup {
            position: fixed;
            background-color: #ffffff;
            padding: 16px;
            border-radius: 4px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 3000;
            display: none;
        }
        #file-popup {
            top: 72px;
            right: 16px;
            width: 152px;
        }
        #menu-popup {
            top: 72px;
            left: 16px;
            text-align: left;
            width: 200px;
        }
        .popup button {
            padding: 6px 16px;
            border-radius: 4px;
            background-color: #3f51b5;
            color: #ffffff;
            border: none;
            cursor: pointer;
            margin: 4px 0;
            width: 120px;
            text-align: center;
        }
        .popup button:hover { background-color: #303f9f; }
        .popup .start-fresh-btn {
            background-color: #0F9D58;
        }
        .popup .start-fresh-btn:hover { background-color: #0a7d44; }
        .popup .file-btn {
            background-color: #f5f5f5;
            color: #212121;
            margin: 4px 0;
            width: 120px;
            text-align: center;
            text-transform: uppercase;
        }
        .popup .file-btn:hover { background-color: #e0e0e0; }
        .popup .file-btn:active { background-color: #bdbdbd; }
        .popup input {
            margin-bottom: 8px;
            padding: 8px;
            width: 200px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-family: 'Roboto', Arial, sans-serif;
        }
        #arrow-prompt {
            position: fixed;
            bottom: 72px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 4px;
            font-family: 'Roboto', Arial, sans-serif;
            font-size: 14px;
            z-index: 4000;
            display: none;
        }
        #file-input {
            display: none;
        }
        .textbox {
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .textbox-small { font-size: 12px; }
        .textbox-medium { font-size: 16px; }
        .textbox-large { font-size: 20px; }
        .control-buttons {
            display: none;
        }
        .triangle-button {
            cursor: pointer;
        }
        .triangle-up {
            fill: #000000;
        }
        .triangle-down {
            fill: #000000;
        }
        .moving-triangle {
            fill: #000000;
            transition: transform 1s linear;
        }
        #mobile-instructions {
            display: none;
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #212121;
            text-align: center;
            width: 100%;
            padding: 0 8px;
            box-sizing: border-box;
        }
        @media (max-width: 600px) {
            .menu-bar {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 100px;
                flex-wrap: wrap;
                justify-content: center;
                padding: 4px 8px;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.12);
                z-index: 1000;
                touch-action: none;
            }
            .menu-bar button {
                font-size: 12px;
                padding: 4px 12px;
            }
            #menu-options {
                justify-content: center;
            }
            #reset-zoom-btn {
                bottom: 112px;
            }
            #play-button {
                bottom: 112px;
            }
            #mobile-instructions {
                display: block;
            }
            #flowchart-container {
                height: calc(100vh - 164px);
            }
        }
    </style>
</head>
<body>
    <div id="title-container">
        <button id="menu-button" onclick="toggleMenuPopup()">
            <i class="material-icons" style="vertical-align: middle;">menu</i>
        </button>
        <div>
            <h1 id="title">U.S. Imposes Tariffs</h1>
            <p id="subheading">Impact to U.S. vs Australian Economy</p>
        </div>
        <div id="top-buttons">
            <button onclick="toggleFilePopup()">
                <i class="material-icons" style="vertical-align: middle;">save</i>
            </button>
        </div>
    </div>
    <div id="flowchart-container">
        <svg id="flowchart">
            <g id="nodes"></g>
            <g id="arrows"></g>
            <g id="arrow-labels"></g>
            <g id="textboxes"></g>
            <g id="moving-triangles"></g>
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#000000"/>
                </marker>
                <clipPath id="circle-clip">
                    <circle cx="0" cy="0" r="50"/>
                </clipPath>
            </defs>
        </svg>
    </div>
    <div id="arrow-prompt">Click a circle to add an arrow</div>
    <button id="reset-zoom-btn" onclick="resetView()">
        <i class="material-icons" style="vertical-align: middle;">zoom_out_map</i>
    </button>
    <div id="play-button">
        <div class="play-icon"></div>
    </div>
    <div class="menu-bar">
        <div id="mobile-instructions">Tap to select, double-tap to edit</div>
        <button id="add-circle-btn" onclick="addCircle()">Add Circle</button>
        <div id="menu-options"></div>
    </div>
    <div id="file-popup" class="popup">
        <button class="file-btn" onclick="saveFlowchart()">Save to Device</button>
        <button class="file-btn" onclick="document.getElementById('file-input').click()">Upload</button>
        <input type="file" id="file-input" accept=".txt" onchange="loadFlowchart(event)">
    </div>
    <div id="menu-popup" class="popup">
        <button class="start-fresh-btn" onclick="startFresh()">New Chart</button>
        <!<button onclick="loadTemplate(1)"></button>
        <!<button onclick="loadTemplate(2)"></button>
        <!<button onclick="loadTemplate(3)"></button>
        <!<button onclick="loadTemplate(4)"></button>
        <p>Make your own flowchart!</p>
        <p>© 2025 simulations.cc</p>
    </div>

    <script src="https://unpkg.com/@material-ui/core@latest/umd/material-ui.production.min.js"></script>
    <script>
        const container = document.getElementById('flowchart-container');
        const svg = document.getElementById('flowchart');
        const nodesGroup = document.getElementById('nodes');
        const arrowsGroup = document.getElementById('arrows');
        const arrowLabelsGroup = document.getElementById('arrow-labels');
        const textboxesGroup = document.getElementById('textboxes');
        const movingTrianglesGroup = document.getElementById('moving-triangles');
        const menuOptions = document.getElementById('menu-options');
        const arrowPrompt = document.getElementById('arrow-prompt');
        const resetZoomBtn = document.getElementById('reset-zoom-btn');
        const playButton = document.getElementById('play-button');
        const title = document.getElementById('title');
        const subheading = document.getElementById('subheading');
        const filePopup = document.getElementById('file-popup');
        const menuPopup = document.getElementById('menu-popup');
        const mobileInstructions = document.getElementById('mobile-instructions');

        let nodeData = {};
        let connections = [];
        let textboxData = {};
        let nextNodeId = 1;
        let nextArrowId = 1;
        let nextTextboxId = 1;
        let selectedCircle = null;
        let selectedArrow = null;
        let selectedTextbox = null;
        let addingArrow = false;
        let viewBoxWidth = 800;
        let viewBoxHeight = 600;
        let viewBoxX = 0;
        let viewBoxY = 0;
        let isDraggingCanvas = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartViewBoxX = 0;
        let dragStartViewBoxY = 0;
        let lastTap = 0;
        let simulationMode = false;
        const circleState = {};
        const maxCount = 20;

        const initialNodes = [
            { id: `node-${nextNodeId++}`, x: 150, y: 50, text: 'aus export costs to u.s.', class: 'node-green' },
            { id: `node-${nextNodeId++}`, x: 350, y: 50, text: 'aus export revenue', class: 'node-green' },
            { id: `node-${nextNodeId++}`, x: 540, y: 70, text: 'aus growth', class: 'node-green' },
            { id: `node-${nextNodeId++}`, x: 150, y: 250, text: 'u.s. import costs', class: 'node-blue' },
            { id: `node-${nextNodeId++}`, x: 350, y: 250, text: 'demand for imports', class: 'node-blue' },
            { id: `node-${nextNodeId++}`, x: 540, y: 250, text: 'demand for u.s. goods', class: 'node-blue' },
            { id: `node-${nextNodeId++}`, x: -20, y: 170, text: 'u.s. imposes new tariffs', class: 'node-red' },
            { id: `node-${nextNodeId++}`, x: 200, y: 400, text: 'u.s. consumer prices', class: 'node-blue' },
            { id: `node-${nextNodeId++}`, x: 400, y: 400, text: 'u.s. inflation', class: 'node-blue' }
        ];

        const initialConnections = [
            { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-2', label: '-' },
            { id: `arrow-${nextArrowId++}`, from: 'node-2', to: 'node-3', label: '+' },
            { id: `arrow-${nextArrowId++}`, from: 'node-4', to: 'node-1', label: '+' },
            { id: `arrow-${nextArrowId++}`, from: 'node-4', to: 'node-5', label: '-' },
            { id: `arrow-${nextArrowId++}`, from: 'node-5', to: 'node-6', label: '-' },
            { id: `arrow-${nextArrowId++}`, from: 'node-7', to: 'node-4', label: '+' },
            { id: `arrow-${nextArrowId++}`, from: 'node-4', to: 'node-8', label: '+' },
            { id: `arrow-${nextArrowId++}`, from: 'node-8', to: 'node-9', label: '+' }
        ];

        const initialTextboxes = [
            { id: `textbox-${nextTextboxId++}`, x: -20, y: 340, text: ' ', color: '#000000', size: 'medium' }
        ];

        initialNodes.forEach(node => {
            nodeData[node.id] = { x: node.x, y: node.y, r: 50, text: node.text, class: node.class };
            addNodeToSVG(node.id);
            circleState[node.id] = 0;
        });
        connections = initialConnections;
        initialTextboxes.forEach(textbox => {
            textboxData[textbox.id] = { x: textbox.x, y: textbox.y, text: textbox.text, color: textbox.color, size: textbox.size };
            addTextboxToSVG(textbox.id);
        });
        updateArrows();

        if (window.innerWidth <= 600) {
            setTimeout(() => {
                mobileInstructions.style.display = 'none';
            }, 3000);
        }

        document.addEventListener('click', (e) => {
            if (!filePopup.contains(e.target) && filePopup.style.display === 'block' && !e.target.closest('#top-buttons button')) {
                filePopup.style.display = 'none';
            }
            if (!menuPopup.contains(e.target) && menuPopup.style.display === 'block' && !e.target.closest('#menu-button')) {
                menuPopup.style.display = 'none';
            }
        });
        document.addEventListener('touchstart', (e) => {
            if (!filePopup.contains(e.target) && filePopup.style.display === 'block' && !e.target.closest('#top-buttons button')) {
                filePopup.style.display = 'none';
            }
            if (!menuPopup.contains(e.target) && menuPopup.style.display === 'block' && !e.target.closest('#menu-button')) {
                menuPopup.style.display = 'none';
            }
        });

        function editText(currentText, callback) {
            closeEditPopup();
            const popup = document.createElement('div');
            popup.className = 'popup';
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.display = 'block';
            popup.style.touchAction = 'none';
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentText;
            input.style.display = 'block';
            input.style.touchAction = 'none';
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const newText = input.value.trim();
                    if (newText) {
                        callback(newText);
                    }
                    document.body.removeChild(popup);
                }
            });
            const okButton = document.createElement('button');
            okButton.textContent = 'OK';
            okButton.style.touchAction = 'none';
            okButton.onclick = () => {
                const newText = input.value.trim();
                if (newText) {
                    callback(newText);
                }
                document.body.removeChild(popup);
            };
            popup.appendChild(input);
            popup.appendChild(okButton);
            document.body.appendChild(popup);
            input.focus();
            input.select();
            popup.addEventListener('click', (e) => e.stopPropagation());
            popup.addEventListener('touchstart', (e) => e.stopPropagation());
        }

        title.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            editText(title.textContent, (newText) => title.textContent = newText);
        });
        subheading.addEventListener('dblclick', (e) => {
            e.preventDefault();
            e.stopPropagation();
            editText(subheading.textContent, (newText) => subheading.textContent = newText);
        });
        title.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const now = new Date().getTime();
            const timeSinceLastTap = now - lastTap;
            if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
                e.stopPropagation();
                editText(title.textContent, (newText) => title.textContent = newText);
            }
            lastTap = now;
        });
        subheading.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const now = new Date().getTime();
            const timeSinceLastTap = now - lastTap;
            if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
                e.stopPropagation();
                editText(subheading.textContent, (newText) => subheading.textContent = newText);
            }
            lastTap = now;
        });

        function calculateInitialViewBox() {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const id in nodeData) {
                const node = nodeData[id];
                minX = Math.min(minX, node.x - node.r);
                maxX = Math.max(maxX, node.x + node.r);
                minY = Math.min(minY, node.y - node.r);
                maxY = Math.max(maxY, node.y + node.r);
            }
            for (const id in textboxData) {
                const textbox = textboxData[id];
                minX = Math.min(minX, textbox.x - 50);
                maxX = Math.max(maxX, textbox.x + 50);
                minY = Math.min(minY, textbox.y - 20);
                maxY = Math.max(maxY, textbox.y + 20);
            }

            const margin = 50;
            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;
            viewBoxWidth = contentWidth + 2 * margin;
            viewBoxHeight = contentHeight + 2 * margin;

            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const aspectRatio = containerWidth / containerHeight;
            const contentAspectRatio = viewBoxWidth / viewBoxHeight;

            if (aspectRatio > contentAspectRatio) {
                viewBoxWidth = viewBoxHeight * aspectRatio;
            } else {
                viewBoxHeight = viewBoxWidth / aspectRatio;
            }

            viewBoxX = minX - margin - (viewBoxWidth - contentWidth - 2 * margin) / 2;
            viewBoxY = minY - margin - (viewBoxHeight - contentHeight - 2 * margin) / 2;

            svg.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);
            checkResetButtonVisibility();
        }

        function updateViewBox() {
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const aspectRatio = containerWidth / containerHeight;

            let baseWidth = viewBoxWidth;
            let baseHeight = viewBoxHeight;

            if (aspectRatio > baseWidth / baseHeight) {
                baseWidth = baseHeight * aspectRatio;
            } else {
                baseHeight = baseWidth / aspectRatio;
            }

            viewBoxWidth = baseWidth;
            viewBoxHeight = baseHeight;

            svg.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);
            checkResetButtonVisibility();
        }

        function checkResetButtonVisibility() {
            const contentMinX = Math.min(...Object.values(nodeData).map(n => n.x - n.r), ...Object.values(textboxData).map(t => t.x - 50));
            const contentMaxX = Math.max(...Object.values(nodeData).map(n => n.x + n.r), ...Object.values(textboxData).map(t => t.x + 50));
            const contentMinY = Math.min(...Object.values(nodeData).map(n => n.y - n.r), ...Object.values(textboxData).map(t => t.y - 20));
            const contentMaxY = Math.max(...Object.values(nodeData).map(n => n.y + n.r), ...Object.values(textboxData).map(t => t.y + 20));

            const isOutOfView = contentMinX < viewBoxX || contentMaxX > viewBoxX + viewBoxWidth ||
                                contentMinY < viewBoxY || contentMaxY > viewBoxY + viewBoxHeight;

            resetZoomBtn.style.display = isOutOfView ? 'block' : 'none';
        }

        window.addEventListener('resize', updateViewBox);
        calculateInitialViewBox();
        updateViewBox();

        svg.addEventListener('mousedown', (e) => {
            if (!e.target.closest('.draggable') && !e.target.closest('.arrow') && !e.target.closest('.arrow-label') && !e.target.closest('.textbox') && !e.target.closest('.triangle-button')) {
                e.preventDefault();
                isDraggingCanvas = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragStartViewBoxX = viewBoxX;
                dragStartViewBoxY = viewBoxY;
            }
        });

        svg.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                e.preventDefault();
                const rect = svg.getBoundingClientRect();
                const scaleX = viewBoxWidth / rect.width;
                const scaleY = viewBoxHeight / rect.height;
                const dx = (e.clientX - dragStartX) * scaleX;
                const dy = (e.clientY - dragStartY) * scaleY;
                viewBoxX = dragStartViewBoxX - dx;
                viewBoxY = dragStartViewBoxY - dy;
                updateViewBox();
            }
        });

        svg.addEventListener('mouseup', () => {
            isDraggingCanvas = false;
        });

        svg.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1 && !e.target.closest('.draggable') && !e.target.closest('.arrow') && !e.target.closest('.arrow-label') && !e.target.closest('.textbox') && !e.target.closest('.triangle-button')) {
                e.preventDefault();
                isDraggingCanvas = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                dragStartViewBoxX = viewBoxX;
                dragStartViewBoxY = viewBoxY;
            }
        });

        svg.addEventListener('touchmove', (e) => {
            if (isDraggingCanvas && e.touches.length === 1) {
                e.preventDefault();
                const rect = svg.getBoundingClientRect();
                const scaleX = viewBoxWidth / rect.width;
                const scaleY = viewBoxHeight / rect.height;
                const dx = (e.touches[0].clientX - dragStartX) * scaleX;
                const dy = (e.touches[0].clientY - dragStartY) * scaleY;
                viewBoxX = dragStartViewBoxX - dx;
                viewBoxY = dragStartViewBoxY - dy;
                updateViewBox();
            }
        });

        svg.addEventListener('touchend', () => {
            isDraggingCanvas = false;
        });

        function resetView() {
            calculateInitialViewBox();
            updateViewBox();
        }

        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            let lines = [];
            let currentLine = words[0];
            for (let i = 1; i < words.length; i++) {
                const testLine = currentLine + ' ' + words[i];
                const testWidth = getTextWidth(testLine);
                if (testWidth <= maxWidth) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = words[i];
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function getTextWidth(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = '14px Roboto, Arial';
            return context.measureText(text).width;
        }

        function addNodeToSVG(id) {
            const node = nodeData[id];
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', 'draggable');
            group.setAttribute('data-id', id);

            const clipGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            clipGroup.setAttribute('clip-path', 'url(#circle-clip)');
            clipGroup.setAttribute('transform', `translate(${node.x}, ${node.y})`);

            const fillRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            fillRect.setAttribute('x', -node.r);
            fillRect.setAttribute('y', node.r);
            fillRect.setAttribute('width', node.r * 2);
            fillRect.setAttribute('height', 0);
            fillRect.setAttribute('class', 'node-fill');
            fillRect.setAttribute('fill', getFillColor(node.class));
            clipGroup.appendChild(fillRect);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', node.r);
            circle.setAttribute('fill', 'transparent');
            circle.setAttribute('class', `node ${node.class}`);
            clipGroup.appendChild(circle);

            group.appendChild(clipGroup);

            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('x', node.x);
            textElement.setAttribute('y', node.y);
            textElement.setAttribute('class', 'node-text');

            const maxWidth = node.r * 1.5;
            const lines = wrapText(node.text, maxWidth);
            lines.forEach((line, index) => {
                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspan.setAttribute('x', node.x);
                tspan.setAttribute('dy', index === 0 ? `${- (lines.length - 1) * 7}px` : '14px');
                tspan.textContent = line;
                textElement.appendChild(tspan);
            });

            group.appendChild(textElement);

            const controls = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            controls.setAttribute('class', 'control-buttons');

            const upButton = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            upButton.setAttribute('d', `M ${node.x - 10} ${node.y - 35} L ${node.x + 10} ${node.y - 35} L ${node.x} ${node.y - 45} Z`);
            upButton.setAttribute('class', 'triangle-button triangle-up');
            upButton.addEventListener('click', (e) => { e.stopPropagation(); handleTriangleClick(id, 'up'); });
            upButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (simulationMode) handleTriangleClick(id, 'up');
            });
            controls.appendChild(upButton);

            const downButton = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            downButton.setAttribute('d', `M ${node.x - 10} ${node.y + 35} L ${node.x + 10} ${node.y + 35} L ${node.x} ${node.y + 45} Z`);
            downButton.setAttribute('class', 'triangle-button triangle-down');
            downButton.addEventListener('click', (e) => { e.stopPropagation(); handleTriangleClick(id, 'down'); });
            downButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (simulationMode) handleTriangleClick(id, 'down');
            });
            controls.appendChild(downButton);

            group.appendChild(controls);

            group.addEventListener('click', (e) => {
                e.stopPropagation();
                if (addingArrow) {
                    createArrowToCircle(id);
                } else if (!simulationMode) {
                    selectCircle(id);
                }
            });
            group.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    if (addingArrow) {
                        createArrowToCircle(id);
                    } else if (!simulationMode) {
                        selectCircle(id);
                    }
                }
            });

            group.addEventListener('dblclick', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!simulationMode) {
                    editText(nodeData[id].text, (newText) => updateNodeText(id, newText));
                }
            });
            group.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const now = new Date().getTime();
                const timeSinceLastTap = now - lastTap;
                if (timeSinceLastTap < 300 && timeSinceLastTap > 0 && !simulationMode) {
                    e.stopPropagation();
                    editText(nodeData[id].text, (newText) => updateNodeText(id, newText));
                }
                lastTap = now;
            });

            group.addEventListener('mousedown', startDraggingTouch);
            group.addEventListener('touchstart', startDraggingTouch);
            nodesGroup.appendChild(group);
            updateCircleFill(id);
        }

        function getFillColor(nodeClass) {
            switch (nodeClass) {
                case 'node-red': return 'rgba(255, 82, 82, 0.8)';
                case 'node-blue': return 'rgba(66, 133, 244, 0.8)';
                case 'node-green': return 'rgba(15, 157, 88, 0.8)';
                case 'node-purple': return 'rgba(156, 39, 176, 0.8)';
                case 'node-orange': return 'rgba(255, 152, 0, 0.8)';
                default: return 'rgba(255, 82, 82, 0.8)';
            }
        }

        function getEdgePoint(from, to, radius) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            return {
                x: from.x + radius * Math.cos(angle),
                y: from.y + radius * Math.sin(angle)
            };
        }

        function updateArrows() {
            arrowsGroup.innerHTML = '';
            arrowLabelsGroup.innerHTML = '';
            const arrowPairs = {};

            connections.forEach(conn => {
                const fromNode = nodeData[conn.from];
                const toNode = nodeData[conn.to];
                if (!fromNode || !toNode) return;

                const start = getEdgePoint(fromNode, toNode, fromNode.r);
                const end = getEdgePoint(toNode, fromNode, toNode.r);

                const pairKey = [conn.from, conn.to].sort().join('-');
                if (!arrowPairs[pairKey]) arrowPairs[pairKey] = [];
                arrowPairs[pairKey].push({ id: conn.id, from: conn.from, to: conn.to, label: conn.label });

                const arrowsBetweenPair = arrowPairs[pairKey];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                const maxOffset = 30;
                const curveFactor = Math.min(distance / 100, 1);
                let curveOffset;

                if (arrowsBetweenPair.length === 1) {
                    curveOffset = 20 * curveFactor;
                } else {
                    const hasOpposite = arrowsBetweenPair.some(a =>
                        (a.from === conn.to && a.to === conn.from)
                    );
                    if (hasOpposite && arrowsBetweenPair.length === 2) {
                        const isForward = conn.from < conn.to;
                        curveOffset = isForward ? -30 * curveFactor : 30 * curveFactor;
                    } else {
                        const index = arrowsBetweenPair.findIndex(a => a.id === conn.id);
                        const direction = (index % 2 === 0) ? 1 : -1;
                        const offsetMultiplier = Math.floor(index / 2) + 1;
                        curveOffset = direction * maxOffset * offsetMultiplier * curveFactor;
                    }
                }

                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                const controlX = midX + curveOffset * Math.cos(angle + Math.PI / 2);
                const controlY = midY + curveOffset * Math.sin(angle + Math.PI / 2);

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M${start.x},${start.y} Q${controlX},${controlY} ${end.x},${end.y}`);
                path.setAttribute('class', 'arrow');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                path.setAttribute('data-id', conn.id);
                if (conn.id === selectedArrow) path.classList.add('selected-glow');
                path.addEventListener('click', (e) => { e.stopPropagation(); if (!simulationMode) selectArrow(conn.id); });
                path.addEventListener('touchstart', (e) => { e.preventDefault(); if (!simulationMode) selectArrow(conn.id); });
                arrowsGroup.appendChild(path);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', controlX);
                label.setAttribute('y', controlY);
                label.setAttribute('class', 'arrow-label');
                label.textContent = conn.label;
                label.setAttribute('data-id', conn.id);
                if (conn.id === selectedArrow) label.classList.add('selected-glow');
                label.addEventListener('click', (e) => { e.stopPropagation(); if (!simulationMode) selectArrow(conn.id); });
                label.addEventListener('touchstart', (e) => { e.preventDefault(); if (!simulationMode) selectArrow(conn.id); });
                arrowLabelsGroup.appendChild(label);
            });
        }

        svg.addEventListener('click', (e) => {
            if (!e.target.closest('.draggable') && !e.target.closest('.arrow') && !e.target.closest('.arrow-label') && !e.target.closest('.textbox') && !e.target.closest('.triangle-button')) {
                deselectAll();
            }
        });

        svg.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                if (!e.target.closest('.draggable') && !e.target.closest('.arrow') && !e.target.closest('.arrow-label') && !e.target.closest('.textbox') && !e.target.closest('.triangle-button')) {
                    deselectAll();
                }
            }
        });

        let draggedNode = null;
        let draggedTextbox = null;
        let offsetX, offsetY;

        function startDraggingTouch(e) {
            e.preventDefault();
            if (e.type === 'touchstart' && e.touches.length !== 1) return;
            const target = e.currentTarget;
            const rect = svg.getBoundingClientRect();
            const scaleX = viewBoxWidth / rect.width;
            const scaleY = viewBoxHeight / rect.height;
            const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
            const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
            const touchX = clientX - rect.left;
            const touchY = clientY - rect.top;

            if (target.classList.contains('draggable') && !simulationMode) {
                draggedNode = target;
                const circle = draggedNode.querySelector('circle');
                offsetX = touchX * scaleX - parseFloat(circle.parentElement.getAttribute('transform').match(/translate\(([^,]+),/)[1]);
                offsetY = touchY * scaleY - parseFloat(circle.parentElement.getAttribute('transform').match(/translate\([^,]+,([^)]+)\)/)[1]);
            } else if (target.classList.contains('textbox') && !simulationMode) {
                draggedTextbox = target;
                offsetX = touchX * scaleX - parseFloat(target.getAttribute('x'));
                offsetY = touchY * scaleY - parseFloat(target.getAttribute('y'));
            }
            svg.addEventListener('mousemove', drag);
            svg.addEventListener('mouseup', stopDragging);
            svg.addEventListener('touchmove', dragTouch);
            svg.addEventListener('touchend', stopDraggingTouch);
        }

        function drag(e) {
            e.preventDefault();
            if (!draggedNode && !draggedTextbox) return;
            const rect = svg.getBoundingClientRect();
            const scaleX = viewBoxWidth / rect.width;
            const scaleY = viewBoxHeight / rect.height;
            const x = (e.clientX - rect.left) * scaleX - offsetX;
            const y = (e.clientY - rect.top) * scaleY - offsetY;

            if (draggedNode) {
                const clipGroup = draggedNode.querySelector('g[clip-path]');
                const text = draggedNode.querySelector('text');
                const controls = draggedNode.querySelector('.control-buttons');
                clipGroup.setAttribute('transform', `translate(${x}, ${y})`);
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                const tspans = text.querySelectorAll('tspan');
                tspans.forEach((tspan, index) => {
                    tspan.setAttribute('x', x);
                    tspan.setAttribute('dy', index === 0 ? `${- (tspans.length - 1) * 7}px` : '14px');
                });
                const upButton = controls.querySelector('.triangle-up');
                const downButton = controls.querySelector('.triangle-down');
                upButton.setAttribute('d', `M ${x - 10} ${y - 35} L ${x + 10} ${y - 35} L ${x} ${y - 45} Z`);
                downButton.setAttribute('d', `M ${x - 10} ${y + 35} L ${x + 10} ${y + 35} L ${x} ${y + 45} Z`);
                const id = draggedNode.getAttribute('data-id');
                nodeData[id].x = x;
                nodeData[id].y = y;
                updateArrows();
            } else if (draggedTextbox) {
                draggedTextbox.setAttribute('x', x);
                draggedTextbox.setAttribute('y', y);
                const id = draggedTextbox.getAttribute('data-id');
                textboxData[id].x = x;
                textboxData[id].y = y;
            }
        }

        function dragTouch(e) {
            e.preventDefault();
            if (!draggedNode && !draggedTextbox || e.touches.length !== 1) return;
            const rect = svg.getBoundingClientRect();
            const scaleX = viewBoxWidth / rect.width;
            const scaleY = viewBoxHeight / rect.height;
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            const x = touchX * scaleX - offsetX;
            const y = touchY * scaleY - offsetY;

            if (draggedNode) {
                const clipGroup = draggedNode.querySelector('g[clip-path]');
                const text = draggedNode.querySelector('text');
                const controls = draggedNode.querySelector('.control-buttons');
                clipGroup.setAttribute('transform', `translate(${x}, ${y})`);
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                const tspans = text.querySelectorAll('tspan');
                tspans.forEach((tspan, index) => {
                    tspan.setAttribute('x', x);
                    tspan.setAttribute('dy', index === 0 ? `${- (tspans.length - 1) * 7}px` : '14px');
                });
                const upButton = controls.querySelector('.triangle-up');
                const downButton = controls.querySelector('.triangle-down');
                upButton.setAttribute('d', `M ${x - 10} ${y - 35} L ${x + 10} ${y - 35} L ${x} ${y - 45} Z`);
                downButton.setAttribute('d', `M ${x - 10} ${y + 35} L ${x + 10} ${y + 35} L ${x} ${y + 45} Z`);
                const id = draggedNode.getAttribute('data-id');
                nodeData[id].x = x;
                nodeData[id].y = y;
                updateArrows();
            } else if (draggedTextbox) {
                draggedTextbox.setAttribute('x', x);
                draggedTextbox.setAttribute('y', y);
                const id = draggedTextbox.getAttribute('data-id');
                textboxData[id].x = x;
                textboxData[id].y = y;
            }
        }

        function stopDragging() {
            draggedNode = null;
            draggedTextbox = null;
            svg.removeEventListener('mousemove', drag);
            svg.removeEventListener('mouseup', stopDragging);
        }

        function stopDraggingTouch() {
            draggedNode = null;
            draggedTextbox = null;
            svg.removeEventListener('touchmove', dragTouch);
            svg.removeEventListener('touchend', stopDraggingTouch);
        }

        function addCircle() {
            const id = `node-${nextNodeId++}`;
            const centerX = viewBoxWidth / 2 + viewBoxX;
            const centerY = viewBoxHeight / 2 + viewBoxY;
            nodeData[id] = { x: centerX, y: centerY, r: 50, text: `new circle ${nextNodeId}`, class: 'node-blue' };
            circleState[id] = 0;
            addNodeToSVG(id);
            updateArrows();
        }

        function addTextbox() {
            const id = `textbox-${nextTextboxId++}`;
            const centerX = viewBoxWidth / 2 + viewBoxX;
            const centerY = viewBoxHeight / 2 + viewBoxY;
            textboxData[id] = { x: centerX, y: centerY, text: 'New Textbox', color: '#000000', size: 'medium' };
            addTextboxToSVG(id);
        }

        function addTextboxToSVG(id) {
            const textbox = textboxData[id];
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('x', textbox.x);
            textElement.setAttribute('y', textbox.y);
            textElement.setAttribute('class', `textbox textbox-${textbox.size}`);
            textElement.setAttribute('fill', textbox.color);
            textElement.setAttribute('data-id', id);
            textElement.textContent = textbox.text;

            textElement.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!simulationMode) selectTextbox(id);
            });
            textElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && !simulationMode) {
                    selectTextbox(id);
                }
            });

            textElement.addEventListener('dblclick', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!simulationMode) {
                    editText(textboxData[id].text, (newText) => updateTextboxText(id, newText));
                }
            });
            textElement.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const now = new Date().getTime();
                const timeSinceLastTap = now - lastTap;
                if (timeSinceLastTap < 300 && timeSinceLastTap > 0 && !simulationMode) {
                    e.stopPropagation();
                    editText(textboxData[id].text, (newText) => updateTextboxText(id, newText));
                }
                lastTap = now;
            });

            textElement.addEventListener('mousedown', startDraggingTouch);
            textElement.addEventListener('touchstart', startDraggingTouch);

            textboxesGroup.appendChild(textElement);
        }

        function findNodeAtPoint(clientX, clientY) {
            const rect = svg.getBoundingClientRect();
            const scaleX = viewBoxWidth / rect.width;
            const scaleY = viewBoxHeight / rect.height;
            const x = (clientX - rect.left) * scaleX + viewBoxX;
            const y = (clientY - rect.top) * scaleY + viewBoxY;

            for (const id in nodeData) {
                const node = nodeData[id];
                const dx = x - node.x;
                const dy = y - node.y;
                if (Math.sqrt(dx * dx + dy * dy) <= node.r) {
                    return id;
                }
            }
            return null;
        }

        function selectCircle(id) {
            deselectAll();
            selectedCircle = id;
            const group = nodesGroup.querySelector(`[data-id="${id}"]`);
            group.classList.add('selected-glow');
            updateMenuOptions();
        }

        function selectArrow(id) {
            deselectAll();
            selectedArrow = id;
            updateArrows();
            updateMenuOptions();
        }

        function selectTextbox(id) {
            deselectAll();
            selectedTextbox = id;
            const textbox = textboxesGroup.querySelector(`[data-id="${id}"]`);
            textbox.classList.add('selected-glow');
            updateMenuOptions();
        }

        function deselectAll() {
            selectedCircle = null;
            selectedArrow = null;
            selectedTextbox = null;
            addingArrow = false;
            arrowPrompt.style.display = 'none';
            closeEditPopup();
            nodesGroup.querySelectorAll('.draggable').forEach(g => g.classList.remove('selected-glow'));
            arrowsGroup.querySelectorAll('.arrow').forEach(a => a.classList.remove('selected-glow'));
            arrowLabelsGroup.querySelectorAll('.arrow-label').forEach(l => l.classList.remove('selected-glow'));
            textboxesGroup.querySelectorAll('.textbox').forEach(t => t.classList.remove('selected-glow'));
            updateMenuOptions();
        }

        function startAddingArrowFromCircle() {
            if (!selectedCircle) return;
            addingArrow = true;
            arrowPrompt.style.display = 'block';
            updateMenuOptions();
        }

        function createArrowToCircle(targetCircleId) {
            if (targetCircleId && targetCircleId !== selectedCircle) {
                const id = `arrow-${nextArrowId++}`;
                connections.push({ id, from: selectedCircle, to: targetCircleId, label: '+' });
                updateArrows();
                selectArrow(id);
                stopAddingArrowFromCircle();
            }
        }

        function stopAddingArrowFromCircle() {
            addingArrow = false;
            arrowPrompt.style.display = 'none';
            updateMenuOptions();
        }

        function editNodeText(id) {
            editText(nodeData[id].text, (newText) => updateNodeText(id, newText));
        }

        function updateNodeText(id, newText) {
            if (newText) {
                nodeData[id].text = newText.toLowerCase();
                const group = nodesGroup.querySelector(`[data-id="${id}"]`);
                const textElement = group.querySelector('text');
                textElement.innerHTML = '';
                const maxWidth = nodeData[id].r * 1.5;
                const lines = wrapText(newText.toLowerCase(), maxWidth);
                lines.forEach((line, index) => {
                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    tspan.setAttribute('x', nodeData[id].x);
                    tspan.setAttribute('dy', index === 0 ? `${- (lines.length - 1) * 7}px` : '14px');
                    tspan.textContent = line;
                    textElement.appendChild(tspan);
                });
            }
        }

        function editTextboxText(id) {
            editText(textboxData[id].text, (newText) => updateTextboxText(id, newText));
        }

        function updateTextboxText(id, newText) {
            if (newText) {
                textboxData[id].text = newText;
                const textbox = textboxesGroup.querySelector(`[data-id="${id}"]`);
                textbox.textContent = newText;
            }
        }

        function closeEditPopup() {
            const popup = document.querySelector('.popup:not(#file-popup):not(#menu-popup)');
            if (popup) {
                document.body.removeChild(popup);
            }
        }

        function updateMenuOptions() {
            menuOptions.innerHTML = '';
            const addCircleBtn = document.getElementById('add-circle-btn');
            if (!selectedCircle && !selectedTextbox && !selectedArrow && !simulationMode) {
                addCircleBtn.style.display = 'block';
                const addTextboxBtn = document.createElement('button');
                addTextboxBtn.textContent = 'Add Textbox';
                addTextboxBtn.onclick = addTextbox;
                addTextboxBtn.style.marginLeft = '8px';
                menuOptions.appendChild(addTextboxBtn);
            } else {
                addCircleBtn.style.display = 'none';
            }

            if (selectedCircle && !simulationMode) {
                const changeColorBtn = document.createElement('button');
                changeColorBtn.textContent = 'Change Color';
                changeColorBtn.onclick = changeCircleColor;
                menuOptions.appendChild(changeColorBtn);

                const editTextBtn = document.createElement('button');
                editTextBtn.textContent = 'Edit Text';
                editTextBtn.onclick = () => editNodeText(selectedCircle);
                menuOptions.appendChild(editTextBtn);

                const addArrowBtn = document.createElement('button');
                addArrowBtn.textContent = 'Add Arrow';
                addArrowBtn.onclick = startAddingArrowFromCircle;
                menuOptions.appendChild(addArrowBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = deleteCircle;
                menuOptions.appendChild(deleteBtn);
            } else if (selectedArrow && !simulationMode) {
                const changeDirectionBtn = document.createElement('button');
                changeDirectionBtn.textContent = 'Reverse';
                changeDirectionBtn.onclick = changeArrowDirection;
                menuOptions.appendChild(changeDirectionBtn);

                const toggleLabelBtn = document.createElement('button');
                toggleLabelBtn.textContent = 'Toggle +/-';
                toggleLabelBtn.onclick = toggleArrowLabel;
                menuOptions.appendChild(toggleLabelBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = deleteArrow;
                menuOptions.appendChild(deleteBtn);
            } else if (selectedTextbox && !simulationMode) {
                const changeColorBtn = document.createElement('button');
                changeColorBtn.textContent = 'Change Color';
                changeColorBtn.onclick = changeTextboxColor;
                menuOptions.appendChild(changeColorBtn);

                const toggleSizeBtn = document.createElement('button');
                toggleSizeBtn.textContent = 'Toggle Size';
                toggleSizeBtn.onclick = toggleTextboxSize;
                menuOptions.appendChild(toggleSizeBtn);

                const editTextBtn = document.createElement('button');
                editTextBtn.textContent = 'Edit Text';
                editTextBtn.onclick = () => editTextboxText(selectedTextbox);
                menuOptions.appendChild(editTextBtn);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = deleteTextbox;
                menuOptions.appendChild(deleteBtn);
            }
        }

        function changeCircleColor() {
            if (!selectedCircle) return;
            const node = nodeData[selectedCircle];
            const colors = ['node-red', 'node-blue', 'node-green', 'node-purple', 'node-orange'];
            const currentIndex = colors.indexOf(node.class);
            node.class = colors[(currentIndex + 1) % colors.length];
            const group = nodesGroup.querySelector(`[data-id="${selectedCircle}"]`);
            const circle = group.querySelector('circle');
            const fillRect = group.querySelector('.node-fill');
            circle.setAttribute('class', `node ${node.class}`);
            fillRect.setAttribute('fill', getFillColor(node.class));
        }

        function deleteCircle() {
            if (!selectedCircle) return;
            delete nodeData[selectedCircle];
            delete circleState[selectedCircle];
            const group = nodesGroup.querySelector(`[data-id="${selectedCircle}"]`);
            nodesGroup.removeChild(group);
            connections = connections.filter(conn => conn.from !== selectedCircle && conn.to !== selectedCircle);
            updateArrows();
            deselectAll();
        }

        function changeArrowDirection() {
            if (!selectedArrow) return;
            const conn = connections.find(c => c.id === selectedArrow);
            if (conn) {
                [conn.from, conn.to] = [conn.to, conn.from];
                updateArrows();
            }
        }

        function toggleArrowLabel() {
            if (!selectedArrow) return;
            const conn = connections.find(c => c.id === selectedArrow);
            if (conn) {
                conn.label = conn.label === '+' ? '-' : '+';
                updateArrows();
            }
        }

        function deleteArrow() {
            if (!selectedArrow) return;
            connections = connections.filter(conn => conn.id !== selectedArrow);
            updateArrows();
            deselectAll();
        }

        function changeTextboxColor() {
            if (!selectedTextbox) return;
            const textbox = textboxData[selectedTextbox];
            const colors = ['#000000', '#FF5252', '#4285F4', '#0F9D58', '#9C27B0'];
            const currentIndex = colors.indexOf(textbox.color);
            textbox.color = colors[(currentIndex + 1) % colors.length];
            const element = textboxesGroup.querySelector(`[data-id="${selectedTextbox}"]`);
            element.setAttribute('fill', textbox.color);
        }

        function toggleTextboxSize() {
            if (!selectedTextbox) return;
            const textbox = textboxData[selectedTextbox];
            const sizes = ['small', 'medium', 'large'];
            const currentIndex = sizes.indexOf(textbox.size);
            textbox.size = sizes[(currentIndex + 1) % sizes.length];
            const element = textboxesGroup.querySelector(`[data-id="${selectedTextbox}"]`);
            element.className.baseVal = `textbox textbox-${textbox.size}${selectedTextbox === selectedTextbox ? ' selected-glow' : ''}`;
        }

        function deleteTextbox() {
            if (!selectedTextbox) return;
            delete textboxData[selectedTextbox];
            const textbox = textboxesGroup.querySelector(`[data-id="${selectedTextbox}"]`);
            textboxesGroup.removeChild(textbox);
            deselectAll();
        }

        function toggleFilePopup() {
            filePopup.style.display = filePopup.style.display === 'block' ? 'none' : 'block';
        }

        function toggleMenuPopup() {
            menuPopup.style.display = menuPopup.style.display === 'block' ? 'none' : 'block';
        }

        // --- SAVE FUNCTION ---
        // Downloads flowchart data as a .txt file
        function saveFlowchart() {
            const data = {
                title: title.textContent,
                subheading: subheading.textContent,
                nodes: nodeData,
                connections: connections,
                textboxes: textboxData,
                nextNodeId: nextNodeId,
                nextArrowId: nextArrowId,
                nextTextboxId: nextTextboxId,
                viewBox: { width: viewBoxWidth, height: viewBoxHeight, x: viewBoxX, y: viewBoxY },
                circleState: circleState
            };
            // Convert the flowchart data to a JSON string
            const jsonString = JSON.stringify(data, null, 2); // Pretty-print JSON
            // Create a Blob object containing the JSON data as plain text
            const blob = new Blob([jsonString], { type: 'text/plain' });
            // Create a temporary URL for the Blob
            const url = window.URL.createObjectURL(blob);
            // Create a temporary anchor element for downloading
            const a = document.createElement('a');
            a.href = url;
            // Set the filename for the downloaded file (using .txt extension)
            a.download = 'flowchart.txt';
            // Append the anchor to the body (required for Firefox)
            document.body.appendChild(a);
            // Programmatically click the anchor to trigger the download
            a.click();
            // Remove the anchor from the body
            document.body.removeChild(a);
            // Revoke the temporary URL to free up memory
            window.URL.revokeObjectURL(url);
            // Hide the file popup after saving
            toggleFilePopup();
        }

        // --- LOAD FUNCTION ---
        function loadFlowchart(event) {
            const file = event.target.files[0];
            if (!file || !file.name.toLowerCase().endsWith('.txt')) { if(file) alert('Please select a valid .txt file.'); event.target.value = null; return; }
            const reader = new FileReader();
            reader.onload = function(e) {
                let fileContent = e.target.result;
                try {
                    if (fileContent.charCodeAt(0) === 0xFEFF) fileContent = fileContent.substring(1);
                    fileContent = fileContent.trim(); if (!fileContent) throw new Error("File is empty.");
                    const data = JSON.parse(fileContent);
                    if (typeof data !== 'object' || data === null || typeof data.nodes !== 'object' || !Array.isArray(data.connections)) throw new Error("Invalid flowchart data structure.");

                    nodesGroup.innerHTML = ''; arrowsGroup.innerHTML = ''; arrowLabelsGroup.innerHTML = ''; textboxesGroup.innerHTML = ''; movingTrianglesGroup.innerHTML = '';
                    title.textContent = data.title || 'Flowchart Title'; subheading.textContent = data.subheading || 'Subheading Text';
                    nodeData = data.nodes || {}; connections = data.connections || []; textboxData = data.textboxes || {};
                    const maxNodeNum = Math.max(0, ...Object.keys(nodeData).map(id => parseInt(id.split('-')[1] || 0))); const maxArrowNum = Math.max(0, ...connections.map(c => parseInt(c.id.split('-')[1] || 0))); const maxTextboxNum = Math.max(0, ...Object.keys(textboxData).map(id => parseInt(id.split('-')[1] || 0)));
                    nextNodeId = Math.max(data.nextNodeId || 1, maxNodeNum + 1); nextArrowId = Math.max(data.nextArrowId || 1, maxArrowNum + 1); nextTextboxId = Math.max(data.nextTextboxId || 1, maxTextboxNum + 1);
                    Object.assign(circleState, data.circleState || {});
                    for (const id in nodeData) if (!(id in circleState)) circleState[id] = 0;

                    for (const id in nodeData) addNodeToSVG(id); for (const id in textboxData) addTextboxToSVG(id); updateArrows();
                    if (data.viewBox && typeof data.viewBox.x === 'number') { viewBoxX = data.viewBox.x; viewBoxY = data.viewBox.y; viewBoxWidth = data.viewBox.width; viewBoxHeight = data.viewBox.height; } else { calculateInitialViewBox(); }
                    updateViewBox(); deselectAll();
                    if (simulationMode) { simulationMode = false; toggleSimulationMode(false); } else { updateMenuOptions(); }
                    toggleFilePopup();
                } catch (error) { alert(`Error loading flowchart: ${error.message}\nPlease ensure the file is valid.`); console.error("Flowchart Loading Error:", error); console.error("Content Snippet:", fileContent.substring(0, 500)); } finally { event.target.value = null; }
            };
            reader.onerror = function(e) { alert('Error reading file.'); console.error("FileReader error:", reader.error); event.target.value = null; };
            reader.readAsText(file);
        }


        playButton.addEventListener('click', () => {
            simulationMode = !simulationMode;
            toggleSimulationMode(simulationMode);
        });

        function toggleSimulationMode(enable) {
            const controlButtons = nodesGroup.querySelectorAll('.control-buttons');
            const icon = playButton.querySelector('div');
            if (enable) {
                playButton.style.backgroundColor = '#555';
                icon.className = 'stop-icon';
                controlButtons.forEach(button => button.style.display = 'block');
                // Set all circles to half-filled (10/20) when starting simulation
                for (const id in circleState) {
                    circleState[id] = 10; // Set initial simulation state (e.g., half full)
                    updateCircleFill(id);
                }
                deselectAll(); // Cannot edit in simulation mode
            } else {
                playButton.style.backgroundColor = '#000';
                icon.className = 'play-icon';
                controlButtons.forEach(button => button.style.display = 'none');
                resetAllFills(); // Reset fills when stopping simulation
            }
            // Update menu options based on whether simulation mode is active
            updateMenuOptions();
        }


        function resetAllFills() {
            for (const id in circleState) {
                circleState[id] = 0; // Reset state to 0
                updateCircleFill(id); // Update visual fill
            }
        }

        function handleTriangleClick(nodeId, direction) {
            if (!simulationMode) return; // Only work in simulation mode

            const node = nodeData[nodeId];
            const canIncrease = circleState[nodeId] < maxCount;
            const canDecrease = circleState[nodeId] > 0;

            // Determine the change amount (e.g., +/- 1)
            let change = 0;
            if (direction === 'up' && canIncrease) {
                change = 1;
            } else if (direction === 'down' && canDecrease) {
                change = -1;
            }

            if (change !== 0) {
                // Update the clicked node's state and visual
                circleState[nodeId] += change;
                updateCircleFill(nodeId);

                // Find outgoing connections from the clicked node
                const outgoingConnections = connections.filter(conn => conn.from === nodeId);

                // Process each outgoing connection
                outgoingConnections.forEach(conn => {
                    const targetNode = nodeData[conn.to];
                    if (!targetNode) return; // Skip if target node doesn't exist

                    // Determine the effect on the target node (+ or - influence)
                    const influence = conn.label === '+' ? 1 : -1;
                    // Calculate the effective direction of the change on the target
                    const effectiveChange = change * influence;
                    const effectiveDirection = effectiveChange > 0 ? 'up' : 'down';

                    // Animate the moving triangle
                    createMovingTriangle(nodeData[nodeId], targetNode, effectiveDirection);

                    // Propagate the change recursively
                    propagateChange(conn.to, effectiveChange);
                });
            }
        }

        function propagateChange(targetNodeId, changeAmount) {
            const targetNode = nodeData[targetNodeId];
            if (!targetNode || changeAmount === 0) return; // Stop if node doesn't exist or no change

            const currentState = circleState[targetNodeId];
            const newState = Math.max(0, Math.min(maxCount, currentState + changeAmount)); // Clamp between 0 and maxCount
            const actualChange = newState - currentState; // The actual change that occurred after clamping

            if (actualChange !== 0) {
                // Update the target node's state and visual
                circleState[targetNodeId] = newState;
                updateCircleFill(targetNodeId);

                // Find further outgoing connections
                const furtherConnections = connections.filter(conn => conn.from === targetNodeId);

                // Propagate the actual change further
                furtherConnections.forEach(conn => {
                    const nextTargetNode = nodeData[conn.to];
                    if (!nextTargetNode) return;

                    const influence = conn.label === '+' ? 1 : -1;
                    const nextChangeAmount = actualChange * influence; // Use the actual change for propagation
                    const nextEffectiveDirection = nextChangeAmount > 0 ? 'up' : 'down';

                    // Animate
                    createMovingTriangle(targetNode, nextTargetNode, nextEffectiveDirection);

                    // Recursive call
                    propagateChange(conn.to, nextChangeAmount);
                });
            }
        }


        function updateCircleFill(nodeId) {
            const node = nodeData[nodeId];
            const percentage = (circleState[nodeId] || 0) / maxCount; // Use 0 if state is undefined
            const height = node.r * 2 * percentage;
            const y = node.r - height;
            const group = nodesGroup.querySelector(`[data-id="${nodeId}"]`);
            if (!group) return; // Node might have been deleted
            const fillRect = group.querySelector('.node-fill');
            if (fillRect) {
                fillRect.setAttribute('y', y);
                fillRect.setAttribute('height', height);
            }
        }

        function createMovingTriangle(fromNode, toNode, direction) {
            const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            triangle.setAttribute('class', 'moving-triangle');
            const startX = fromNode.x;
            const startY = fromNode.y;
            const endX = toNode.x;
            const endY = toNode.y;

            // Define triangle shape pointing up
            const trianglePath = `M ${-7} ${0} L ${7} ${0} L ${0} ${-10} Z`;
            triangle.setAttribute('d', trianglePath);

            // Initial position and orientation
            let initialTransform = `translate(${startX}, ${startY})`;
            if (direction === 'down') {
                 initialTransform += ` rotate(180)`; // Rotate if moving down
            }
            triangle.setAttribute('transform', initialTransform);

            movingTrianglesGroup.appendChild(triangle);

            // Use requestAnimationFrame for smoother start
            requestAnimationFrame(() => {
                // Target position and orientation
                let finalTransform = `translate(${endX}, ${endY})`;
                 if (direction === 'down') {
                    finalTransform += ` rotate(180)`; // Maintain rotation if moving down
                }
                triangle.style.transition = 'transform 1s linear'; // Apply CSS transition
                triangle.setAttribute('transform', finalTransform);

                // Remove the triangle after the animation duration
                setTimeout(() => {
                    if (triangle.parentNode) { // Check if still attached before removing
                        triangle.remove();
                    }
                }, 1000); // Matches the transition duration
            });
        }


        function startFresh() {
            nodesGroup.innerHTML = '';
            arrowsGroup.innerHTML = '';
            arrowLabelsGroup.innerHTML = '';
            textboxesGroup.innerHTML = '';
            movingTrianglesGroup.innerHTML = '';
            nodeData = {};
            connections = [];
            textboxData = {};
            circleState = {};
            nextNodeId = 1;
            nextArrowId = 1;
            nextTextboxId = 1;
            title.textContent = 'Flowchart Title';
            subheading.textContent = 'Subheading Text';
            calculateInitialViewBox();
            updateViewBox();
            deselectAll();
            toggleMenuPopup();
            // Ensure simulation mode is off when starting fresh
            if (simulationMode) {
                simulationMode = false;
                toggleSimulationMode(false);
            } else {
                 // Still need to reset button appearance if it was already off
                 const icon = playButton.querySelector('div');
                 playButton.style.backgroundColor = '#000';
                 icon.className = 'play-icon';
            }
        }


        function loadTemplate(templateNumber) {
            // Start fresh before loading template
            startFresh();

            let nodes, conns, texts;
            switch (templateNumber) {
                case 1: // Basic Flow
                    nodes = [
                        { id: `node-${nextNodeId++}`, x: 200, y: 100, text: 'input', class: 'node-blue' },
                        { id: `node-${nextNodeId++}`, x: 400, y: 100, text: 'process', class: 'node-green' },
                        { id: `node-${nextNodeId++}`, x: 600, y: 100, text: 'output', class: 'node-red' }
                    ];
                    conns = [
                        { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-2', label: '+' },
                        { id: `arrow-${nextArrowId++}`, from: 'node-2', to: 'node-3', label: '+' }
                    ];
                    texts = [];
                    title.textContent = 'Basic Flow';
                    subheading.textContent = 'Template 1';
                    break;
                case 2: // Simple Path
                    nodes = [
                        { id: `node-${nextNodeId++}`, x: 300, y: 100, text: 'start', class: 'node-purple' },
                        { id: `node-${nextNodeId++}`, x: 300, y: 300, text: 'end', class: 'node-orange' }
                    ];
                    conns = [
                        { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-2', label: '+' }
                    ];
                    texts = [
                        { id: `textbox-${nextTextboxId++}`, x: 300, y: 200, text: 'Simple Path', color: '#000000', size: 'medium' }
                    ];
                    title.textContent = 'Simple Flow';
                    subheading.textContent = 'Template 2';
                    break;
                case 3: // Converging Flow
                    nodes = [
                        { id: `node-${nextNodeId++}`, x: 200, y: 200, text: 'source', class: 'node-red' },
                        { id: `node-${nextNodeId++}`, x: 400, y: 100, text: 'step 1', class: 'node-blue' },
                        { id: `node-${nextNodeId++}`, x: 400, y: 300, text: 'step 2', class: 'node-green' },
                        { id: `node-${nextNodeId++}`, x: 600, y: 200, text: 'result', class: 'node-purple' }
                    ];
                    conns = [
                        { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-2', label: '+' },
                        { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-3', label: '+' },
                        { id: `arrow-${nextArrowId++}`, from: 'node-2', to: 'node-4', label: '+' },
                        { id: `arrow-${nextArrowId++}`, from: 'node-3', to: 'node-4', label: '+' }
                    ];
                    texts = [];
                    title.textContent = 'Converging Flow';
                    subheading.textContent = 'Template 3';
                    break;
                case 4: // Diverging Flow
                    nodes = [
                        { id: `node-${nextNodeId++}`, x: 300, y: 100, text: 'event', class: 'node-orange' },
                        { id: `node-${nextNodeId++}`, x: 200, y: 300, text: 'response 1', class: 'node-blue' },
                        { id: `node-${nextNodeId++}`, x: 400, y: 300, text: 'response 2', class: 'node-green' }
                    ];
                    conns = [
                        { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-2', label: '+' },
                        { id: `arrow-${nextArrowId++}`, from: 'node-1', to: 'node-3', label: '-' } // Example of negative influence
                    ];
                    texts = [
                        { id: `textbox-${nextTextboxId++}`, x: 300, y: 400, text: 'Diverging Paths', color: '#FF5252', size: 'large' }
                    ];
                    title.textContent = 'Diverging Flow';
                    subheading.textContent = 'Template 4';
                    break;
                 default: // Should not happen, but good practice
                    return;
            }

            // Add nodes from the template
            nodes.forEach(node => {
                nodeData[node.id] = { x: node.x, y: node.y, r: 50, text: node.text, class: node.class };
                addNodeToSVG(node.id);
                circleState[node.id] = 0; // Initialize simulation state for template nodes
            });
            // Set connections from the template
            connections = conns;
            // Add textboxes from the template
            texts.forEach(textbox => {
                textboxData[textbox.id] = { x: textbox.x, y: textbox.y, text: textbox.text, color: textbox.color, size: textbox.size };
                addTextboxToSVG(textbox.id);
            });

            // Update visuals
            updateArrows();
            calculateInitialViewBox(); // Recalculate viewbox for the template content
            updateViewBox();
            // Ensure clean state
            deselectAll();
            toggleMenuPopup(); // Close the menu popup
            // Make sure simulation mode is off
            if (simulationMode) {
                 simulationMode = false;
                 toggleSimulationMode(false);
            }
        }

    </script>
</body>
</html>
